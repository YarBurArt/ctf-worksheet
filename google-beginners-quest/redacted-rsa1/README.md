## [Google CTF Beginner's Quest](https://capturetheflag.withgoogle.com/beginners-quest) — Redacted RSA 1
Этот материал открывает серию разборов задач по криптографии с Google CTF Beginner's Quest. Серия выстроена как своеобразный квест: в каждой последующей задаче приватный ключ «ломается» все больше и больше. В Redacted RSA 1 все довольно просто: нам достается приватный ключ, у которого содержимое слегка искажено. Несмотря на повреждения, ключ все еще содержит не только значения открытого ключа (n и e), но и значение приватной экспоненты (d), то есть все необходимые данные для расшифровки флага. Чтобы было понятнее, в Redacted RSA 2 значение d уже слишком повреждено для прямого использования, и придется поискать обходные пути. Но об этом мы поговорим в другой раз. Сейчас сосредоточимся на первой задаче — самой «щадящей» в серии. Этот разбор можно считать своего рода вводным уроком: он не только объяснит решение конкретной задачи, но и освежит базовые принципы работы RSA, так что новичкам материал будет особенно полезен.

Чтобы уверенно двигаться дальше, разберемся, какие кусочки информации прячутся внутри RSA‑ключа. Для опытных криптографов это азы, но новичкам полезно увидеть все разложенным по полочкам.

  -  Модуль (обозначается n) — это произведение двух больших простых чисел p и q. Обычно именно на факторизации n (нахождении этих самых простых чисел) и строится вся сложность RSA.
  -  Публичная экспонента (обозначается e) — в абсолютном большинстве случаев это стандартное значение 65537. Пара (n, e) образует открытый ключ — тот самый, которым шифруют сообщение.
  -  Приватная экспонента (обозначается d) — вместе с n она формирует приватный ключ, который позволяет расшифровать зашифрованное сообщение. В большинстве задач по криптографии, где фигурирует RSA, необходимо рассчитать, восстановить или еще каким-то образом получить значение d. Напомню, в Redacted RSA 1 d нам благополучно достается, что снимает с нас немало головной боли.
  -  Простые множители (обозначаются p и q) — кирпичики, из которых построен модуль n. В идеальных условиях приватный ключ содержит и их тоже. Но здесь ключ поврежден, поэтому p и q достать уже нельзя. Но повторюсь: нам это не нужно, раз есть d.

По сути, авторы задачи намеренно «попортили» второстепенные поля ключа, но оставили нам все самое важное: (n, e, d).

Когда в условии задачи мы видим поврежденный приватный ключ, первые шаги могут показаться пугающими. Но на самом деле все довольно просто: ключ все еще можно разобрать стандартными инструментами. Для этого отлично подходит сервис asn1js — это веб‑декодер ASN.1/DER‑структур (а именно в таком формате закодированы большинство RSA‑ключей). Однако, чтобы ключ был корректно прочитан этим сервисом, необходимо выполнить несколько шагов.

Что нужно сделать:

  1.  Открываем приватный ключ любым текстовым редактором. Видим знакомый блок с -----BEGIN PRIVATE KEY-----, но в нем почему‑то много звездочек *.
  2.  Меняем звездочки на допустимые символы Base64. Например, можно поставить A. Это довольно грубая заплатка, но хватает для того, чтобы сервис смог «прочитать» ключ и разобрать его структуру.
  3.  Загружаем исправленный файл на [сервис](https://lapo.it/asn1js/). Если при загрузке сервис выдает ошибку вроде «Error: Content size is not correct for container at offset 6», значит, где‑то мы неаккуратно заменили символы. Исправляем и пробуем снова.

После этого можно кликать по отдельным полям, копировать значения и радоваться: несмотря на повреждения, ключ не утратил главное — целые значения n и d.

Для тех, кто впервые сталкивается с этим сервисом: достаточно выбрать конкретное поле (например, modulus) и нажать опцию «Copy value». Все, у вас есть большое число в десятичном или шестнадцатеричном виде, с которым дальше можно работать.

На самом деле RSA работает не с файлами или строками, а с целыми числами (очень большими). Сообщение превращают в число, возводят его в степень и делят по модулю n. Шифрование закончено.

Поэтому, когда мы берем данный нам encrypted.txt, внутри это просто набор байтов, который нужно интерпретировать как одно большое число. Но компьютер не умеет угадывать, что мы хотим. Нужен быстрый способ перевести «сырые байты» → «большое десятичное число».

На мой взгляд, самый удобный путь — это Python‑однострочник:
```python
Python:

# Считываем данные из файла
with open("encrypted.txt", "rb") as file:
    byte_data = file.read()

# Переводим байты в большое число
cipher_as_int = int.from_bytes(byte_data, "big")

# Выводим результат
print(cipher_as_int)
```

Для понимания: здесь аргумент "big" означает «big‑endian порядок» — сначала идут старшие байты. Это стандарт в RSA, поэтому не нужно ничего дополнительно шаманить.

Теперь зашифрованный текст представлен в нужном формате.

Итак, у нас на руках есть все необходимое: модуль n, приватная экспонента d и зашифрованный текст c в числовом виде. Настало время превратить шифртекст в обычный флаг.

Самый быстрый путь, особенно если не хочется возиться с библиотеками или вспоминать синтаксис длинных консольных команд, — воспользоваться онлайн‑сервисом RSA Cipher на dCode.

Пошагово это выглядит так:

1. Идем на [сайт](https://www.dcode.fr/) и в поиске находим [нужный](https://www.dcode.fr/rsa-cipher) сервис.
2. Подставляем в соответствующие поля:
    - n (модуль),
    - d (приватная экспонента),
    - c (шифртекст в виде числа).
3. Жмем кнопку CALCULATE/DECRYPT.

Через пару секунд сервис выполнит все вычисления и вернет исходное сообщение — наш флаг в удобочитаемом виде.

Для CTF такой способ особенно практичен: ничего не нужно устанавливать, не нужно иметь дело с зависимостями или командной строкой — все решается прямо в браузере. Вбили числа → нажали кнопку → получили флаг → отправили и наслаждаемся победой.

Хотел бы добавить, что задачка по-прежнему доступна для решения, и вы все еще можете самостоятельно проделать эти шаги и сдать флаг.

---
### made by M4x from [`codeby.net`](https://codeby.net/threads/google-ctf-beginners-quest-redacted-rsa-1-writeup.89958/)